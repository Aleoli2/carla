#!/usr/bin/env python

# Copyright (c) 2023 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

from setuptools import setup, Extension
from pathlib import Path
import subprocess, glob, time, sys, os

PYTHON_API_PATH = Path(__file__).parent
PYTHON_API_INTERMEDIATE_PATH = PYTHON_API_PATH / 'temp'
LICENSE = 'MIT License' if not {ENABLE_RSS} else 'LGPL-v2.1-only License'

PYTHON_API_INTERMEDIATE_PATH.mkdir(exist_ok = True)
PYTHON_API_AMALGAMATED_OBJECT_PATH = PYTHON_API_INTERMEDIATE_PATH / 'libcarla{OBJ_EXT}'
PYTHON_INCLUDE_PATH = (Path(sys.executable).parent / 'include').resolve()

CPP_STANDARD_DIRECTIVE = '/std:' if os.name == 'nt' else '-std='
INCLUDE_PREFIX = '/I' if os.name == 'nt' else '-I'
DEFINE_PREFIX = '/D' if os.name == 'nt' else '-D'

definitions = [
    DEFINE_PREFIX + 'BOOST_ALL_NO_LIB',
    DEFINE_PREFIX + 'BOOST_NO_EXCEPTIONS',
    DEFINE_PREFIX + 'BOOST_PYTHON_STATIC_LIB',
    DEFINE_PREFIX + 'BOOST_ERROR_CODE_HEADER_ONLY',
    DEFINE_PREFIX + 'LIBCARLA_WITH_PYTHON_SUPPORT',
    DEFINE_PREFIX + 'LIBCARLA_IMAGE_WITH_PNG_SUPPORT=true',
    DEFINE_PREFIX + 'BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY',
]

amalgamate_compile_command = [ '{CPP_COMPILER}' ]
amalgamate_compile_command.extend([
    '/c' if os.name == 'nt' else '-c',
    CPP_STANDARD_DIRECTIVE + 'c++{CPP_STANDARD}',
    INCLUDE_PREFIX, '{LIBCARLA_SOURCE_PATH}',
    INCLUDE_PREFIX, '{BOOST_INCLUDE_PATH}',
    INCLUDE_PREFIX, '{RPCLIB_INCLUDE_PATH}',
    INCLUDE_PREFIX, '{LIBPNG_INCLUDE_PATH}',
    INCLUDE_PREFIX, '{ZLIB_INCLUDE_PATH}',
    INCLUDE_PREFIX, '{RECAST_INCLUDE_PATH}',
    INCLUDE_PREFIX, '{XERCESC_INCLUDE_PATH}',
    INCLUDE_PREFIX, '{SQLITE_INCLUDE_PATH}',
    INCLUDE_PREFIX, '{PROJ_INCLUDE_PATH}',
    INCLUDE_PREFIX, '{SUMO_INCLUDE_PATH}',
    INCLUDE_PREFIX, f'{{PYTHON_INCLUDE_PATH}}',
])
amalgamate_compile_command.extend(definitions)

if os.name == 'nt':
    windows_definitions = [
        DEFINE_PREFIX + '_WIN32_WINNT=0x0600',
        DEFINE_PREFIX + 'HAVE_SNPRINTF',
        DEFINE_PREFIX + '_CRT_SECURE_NO_WARNINGS',
    ]
    definitions.extend(windows_definitions)
    amalgamate_compile_command.extend(windows_definitions)
    amalgamate_compile_command.extend([
        '/EHsc',
        '/MD',
        '/bigobj',
    ])
else:
    pass

amalgamate_compile_command.extend([
    PYTHON_API_PATH / 'source' / 'libcarla' / 'libcarla.cpp',
    '/Fo:' if os.name == 'nt' else '-o',
])
amalgamate_compile_command.append(PYTHON_API_AMALGAMATED_OBJECT_PATH)

print(f'Building "{{PYTHON_API_AMALGAMATED_OBJECT_PATH}}".')
subprocess.run(
    amalgamate_compile_command,
    shell = True
).check_returncode()

while not PYTHON_API_AMALGAMATED_OBJECT_PATH.exists():
    time.sleep(0.1)

sources = []
include_paths = []
link_libraries = []

compile_flags = [
    '/experimental:external',
    '/external:W0',
    '/external:I',
]
compile_flags.extend(definitions)

link_flags = [
    sorted(glob.glob(str(Path('{BOOST_INSTALL_PATH}') / 'lib' / 'libboost_python*{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{BOOST_INSTALL_PATH}') / 'lib' / 'libboost_filesystem*{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{RPCLIB_INSTALL_PATH}') / 'lib' / 'rpc{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{LIBCARLA_BUILD_PATH}') / '*carla-client{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{LIBPNG_INSTALL_PATH}') / 'lib' / 'libpng*{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{ZLIB_INSTALL_PATH}') / 'lib' / 'zlib{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{RECAST_INSTALL_PATH}') / 'lib' / 'Recast{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{RECAST_INSTALL_PATH}') / 'lib' / 'Detour{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{RECAST_INSTALL_PATH}') / 'lib' / 'DetourCrowd{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{XERCESC_INSTALL_PATH}') / 'lib' / 'xerces-c*{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{PROJ_INSTALL_PATH}') / 'lib' / 'proj{LIB_EXT}'), recursive = True))[0],
    sorted(glob.glob(str(Path('{SQLITE_BUILD_PATH}') / 'sqlite*{LIB_EXT}'), recursive = True))[0],
]

library_paths = [ str(Path(e).parent) for e in link_flags ]
link_flags = [ str(Path(e).name) for e in link_flags ]

if os.name == 'nt':
    link_flags.extend([
        'shlwapi.lib',
        'Advapi32.lib',
        'ole32.lib',
        'shell32.lib'
    ])

dependencies = glob.glob(str(
    PYTHON_API_PATH / 'source' / 'libcarla' / '*.cpp'),
    recursive = True)

carla_extensions = [
    Extension(
        name = 'libcarla.carla',
        sources = [],
        libraries = link_libraries,
        library_dirs = library_paths,
        extra_compile_args = compile_flags,
        extra_link_args = link_flags,
        extra_objects = [ str(PYTHON_API_AMALGAMATED_OBJECT_PATH) ],
        language = f'c++{CPP_STANDARD}',
        depends = dependencies)
]

readme = ''
with open(PYTHON_API_PATH / 'README.md', 'r') as file:
    readme = file.read()

setup(
    name = 'carla',
    version = '{CARLA_VERSION_STRING}',
    package_dir = {{ '' : 'source' }},
    packages = [ 'carla' ],
    ext_modules = carla_extensions,
    license = LICENSE,
    description = 'Python API for communicating with the CARLA server.',
    long_description = readme,
    long_description_content_type = 'text/markdown',
    url = 'https://github.com/carla-simulator/carla',
    author = 'The CARLA team',
    author_email = 'carla.simulator@gmail.com',
    include_package_data = True,
)